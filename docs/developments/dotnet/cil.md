# CIL

## Table of Contents <!-- omit in toc -->

- [Overview](#overview)
- [Syntax](#syntax)
  - [Comments](#comments)
  - [Keywords](#keywords)
  - [Local Variables](#local-variables)
  - [Operators](#operators)
  - [Load Stack](#load-stack)
  - [Store Stack](#store-stack)
- [Disassembly of C# Code](#disassembly-of-c-code)
  - [About ldarg.0](#about-ldarg0)
- [References](#references)

## Overview

Common Intermediate Language (CIL), pronounced "sil" or "kil," is the lowest-level human-readable programming language defined by the Common Language Infrastructure (CLI). It is used by both the .NET Framework and Mono.

During the beta release of .NET languages, CIL was called Microsoft Intermediate Language (MSIL).

Since the standardization of C\# and the CLI, this bytecode is now officially referred to as CIL.

Having the ability to read CIL is considered a valuable skill for a .NET programmer.

## Syntax

You probably won't be writing programs directly in IL. However, being able to read the code generated by your C\# source can help you optimize your code and improve performance.

`Hello.cil`:

```cil
.assembly extern mscorlib {}  
.assembly Hello {}  
.method static void Main()  
{  
    .entrypoint  
    .maxstack 1  
    ldstr "Hello, world\!"  
    call void \[mscorlib\]System.Console::WriteLine(string)  
    ret  
}
```
<!-- spell-checker: words mscorlib -->
<!-- spell-checker: words maxstack -->
<!-- spell-checker: words ldstr -->

### Comments

You can use C-style comments, such as `//...` and `/* ... */`.

### Keywords

| Keyword | Description |
| :---- | :---- |
| `.entrypoint` | The entry point for the assembly. It is usually placed at the beginning, but can be anywhere. |
| `.maxstack` | The maximum stack size, with a default of 8\. A smaller number can improve performance. |

### Local Variables

Local variables are assigned labels using a 16-bit unsigned integer, allowing for up to 65,535 variables.

```cil
// Declaration
.locals (type name, type name ...)

// Declaring and initializing variables (0)
.locals init (type name, type name ...)
```

### Operators

| Instruction | Opcode | Description |
| :---- | :---- | :---- |
| nop | 0x00 | Does nothing. |
| break | 0x01 | Notifies the debugger to set a breakpoint. |
| ret | 0x2A | Returns from a method. Note: The stack must be empty before ret, or it will cause an InvalidProgramException. |
| add | 0x58 | Adds the contents of the stack and pushes the result back. |
| sub | 0x59 | Subtracts the contents of the stack and pushes the result back. |
| mul | 0x5A | Multiplies the contents of the stack and pushes the result back. |
| div | 0x5B | Divides the contents of the stack and pushes the result back. |
| div.un | 0x5C |  |
| rem | 0x5D | Pushes the remainder of a division from the stack back. |
| rem.un | 0x5E |  |
| sizeof | 0xFE 0x1C |  |
| and | 0x5F |  |
| or | 0x60 |  |
| xor | 0x61 |  |

### Load Stack

| Instruction | Opcode | Description |
| :---- | :---- | :---- |
| ldarg.0 \~ 3 | 0x02 \~ 0x05 | Pushes arguments 0 through 3 onto the stack. |
| ldarg.s | 0x0E | Pushes argument num (uint8) onto the stack. |
| ldarga.s | 0x0F | Pushes the address of argument num (uint8) onto the stack. |
| ldarg | 0xFE 0x09 | Pushes argument num (uint16) onto the stack. |
| ldarga | 0xFE 0x0A | Pushes the address of argument num (uint16) onto the stack. |
| ldloc.0 \~ 3 | 0x06 \~ 0x09 | Pushes local variables 0 through 3 (index) onto the stack. |
| ldloc.s | 0x11 | Pushes local variable index (uint8) onto the stack. |
| ldloca.s | 0x12 | Pushes the address of local variable index (uint8) onto the stack. |
| ldloc | 0xFE 0x0C | Pushes local variable index (uint16) onto the stack. |
| ldloca | 0xFE 0x0D | Pushes the address of local variable index (uint16) onto the stack. |
| ldnull | 0x14 | Pushes a null reference onto the stack. |
| ldc.i4.m1 | 0x15 | Pushes \-1 (int32) onto the stack. |
| ldc.i4.0 \~ 8 | 0x16 \~ 0x1E | Pushes 0 through 8 (int32) onto the stack. |
| ldc.i4.s | 0x1F | Pushes num (int16) onto the stack. |
| ldc.i4 | 0x20 | Pushes num (int32) onto the stack. |
| ldc.i8 | 0x21 | Pushes num (int64) onto the stack. |
| ldc.r4 | 0x22 | Pushes num (float32) onto the stack. |
| ldc.r8 | 0x23 | Pushes num (float64) onto the stack. |
| ldstr | 0x72 | Pushes a literal string onto the stack. |
<!-- spell-checker: words ldarg ldarga ldloc ldloca ldnull  -->

### Store Stack

| Instruction | Opcode | Description |
| :---- | :---- | :---- |
| stloc.0 \~ 3 | 0x0A \~ 0x0D | Pops the stack into local variables 0 through 3 (index). |
| stloc.s | 0x13 | Pops the stack into local variable index (uint8). |
| stloc | 0xFE 0x0E | Pops the stack into local variable index (uint16). |
<!-- spell-checker: words stloc -->

## Disassembly of C\# Code

### About ldarg.0

It seems that C\# methods always start with ldarg.0. ldarg.0 means "push the first (0th) argument onto the stack," but this instruction also appears at the start of methods that have no arguments. This is because for instance methods, the `this` reference is stored as the first argument.

## References

- [共通中間言語 - Wikipedia](https://ja.wikipedia.org/wiki/%E5%85%B1%E9%80%9A%E4%B8%AD%E9%96%93%E8%A8%80%E8%AA%9E)
- [List of CIL instructions - Wikipedia](https://en.wikipedia.org/wiki/List_of_CIL_instructions)
- [ECMA-335 - Ecma International](https://ecma-international.org/publications-and-standards/standards/ecma-335/)
